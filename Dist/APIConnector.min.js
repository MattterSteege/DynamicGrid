/**
 * @version 0.1.0
 */
class APIConnector{constructor(e={}){this.baseUrl=e.baseUrl||"",this.headers={"Content-Type":"application/json",Accept:"application/json",...e.headers},this.timeout=e.timeout||3e4,this.useAuth=e.useAuth||!1,this.authToken=e.authToken||null,this.apiVersion=e.apiVersion,this.abortControllers=new Map,this.endpoints=this.initializeEndpoints(e.endpoints||{}),this.dataTransform=this.initializeDataTransform(e.dataTransform||{}),this.errorHandling=this.initializeErrorHandling(e.errorHandling||{}),this.caching=this.initializeCaching(e.caching||{}),this.validation=this.initializeValidation(e.validation||{}),this.requestInterceptors=[],this.responseInterceptors=[],this.retryConfig={enabled:e.retry?.enabled||!1,maxAttempts:e.retry?.maxAttempts||3,delay:e.retry?.delay||1e3,backoff:e.retry?.backoff||"exponential",retryCondition:e.retry?.retryCondition||this.defaultRetryCondition.bind(this)}}initializeEndpoints(e){return{fetch:{method:"GET",endpoint:"/data"},create:{method:"POST",endpoint:"/data"},update:{method:"PUT",endpoint:"/data/{id}"},patch:{method:"PATCH",endpoint:"/data/{id}"},delete:{method:"DELETE",endpoint:"/data/{id}"},search:{method:"GET",endpoint:"/search"},bulk:{method:"POST",endpoint:"/data/bulk"},...e}}initializeDataTransform(e){return{request:e.request||(e=>e),response:e.response||(e=>e),error:e.error||(e=>e),beforeSend:e.beforeSend||(e=>e),afterReceive:e.afterReceive||(e=>e)}}initializeErrorHandling(e){return{showUserFriendlyMessages:!1!==e.showUserFriendlyMessages,logErrors:!1!==e.logErrors,customErrorMessages:e.customErrorMessages||{},onError:e.onError||null,retryableErrors:e.retryableErrors||[408,429,500,502,503,504]}}initializeCaching(e){return{enabled:e.enabled||!1,ttl:e.ttl||3e5,strategy:e.strategy||"memory",keyGenerator:e.keyGenerator||this.generateCacheKey.bind(this),cache:new Map}}initializeValidation(e){return{enabled:e.enabled||!1,schemas:e.schemas||{},validator:e.validator||this.defaultValidator.bind(this)}}addRequestInterceptor(e){this.requestInterceptors.push(e)}addResponseInterceptor(e){this.responseInterceptors.push(e)}executeOperation(e,t=null,r={}){const s=this.endpoints[e];if(!s)return Promise.reject(new APIError(`Unknown operation: ${e}`,"UNKNOWN_OPERATION",400));return(this.validation.enabled&&t?this.validateData(e,t):Promise.resolve()).then((()=>{const a=this.dataTransform.beforeSend(this.dataTransform.request(t));if("GET"===s.method&&this.caching.enabled){const t=this.caching.keyGenerator(e,a,r),s=this.getFromCache(t);if(s)return Promise.resolve(this.dataTransform.afterReceive(this.dataTransform.response(s)))}let n=s.endpoint;r.pathParams&&(n=this.substitutePathParams(n,r.pathParams));const i={data:a,params:r.params||{},headers:r.headers||{},...r};return(this.retryConfig.enabled?this.executeWithRetry(s.method,n,i):this.request(s.method,n,i)).then((t=>{const n=this.dataTransform.afterReceive(this.dataTransform.response(t));if("GET"===s.method&&this.caching.enabled){const t=this.caching.keyGenerator(e,a,r);this.setCache(t,n)}return n}))}))}fetchData(e={},t={}){return this.executeOperation("fetch",null,{params:e,...t})}createData(e,t={}){return this.executeOperation("create",e,t)}patchData(e,t={}){return this.executeOperation("patch",e,t)}deleteData(e={}){return this.executeOperation("delete",null,e)}searchData(e,t={}){return this.executeOperation("search",e,t)}bulkOperation(e,t={}){return this.executeOperation("bulk",e,t)}executeWithRetry(e,t,r){const s=a=>this.request(e,t,r).catch((e=>{if(a>=this.retryConfig.maxAttempts||!this.retryConfig.retryCondition(e,a))throw e;let t=this.retryConfig.delay;return"exponential"===this.retryConfig.backoff&&(t*=Math.pow(2,a-1)),this.sleep(t).then((()=>s(a+1)))}));return s(1)}defaultRetryCondition(e,t){return this.errorHandling.retryableErrors.includes(e.status)}sleep(e){return new Promise((t=>setTimeout(t,e)))}substitutePathParams(e,t){return e.replace(/\{(\w+)\}/g,((e,r)=>void 0!==t[r]?t[r]:e))}validateData(e,t){const r=this.validation.schemas[e];return r?Promise.resolve(this.validation.validator(t,r)).then((t=>{if(!t)throw new APIError(`Validation failed for ${e}`,"VALIDATION_ERROR",400)})):Promise.resolve()}defaultValidator(e,t){return"function"!=typeof t||t(e)}generateCacheKey(e,t,r){const s={operation:e,data:t||null,params:r.params||{},pathParams:r.pathParams||{}};return JSON.stringify(s)}getFromCache(e){if(!this.caching.enabled)return null;const t=this.caching.cache.get(e);return t&&Date.now()-t.timestamp<this.caching.ttl?t.data:(t&&this.caching.cache.delete(e),null)}setCache(e,t){this.caching.enabled&&this.caching.cache.set(e,{data:t,timestamp:Date.now()})}clearCache(e){if(e){const t=new RegExp(e);for(const e of this.caching.cache.keys())t.test(e)&&this.caching.cache.delete(e)}else this.caching.cache.clear()}setAuthToken(e){this.authToken=e,this.useAuth=!!e}clearAuthToken(){this.authToken=null,this.useAuth=!1}buildUrl(e){const t=e.startsWith("/")?e.substring(1):e;return this.apiVersion?`${this.baseUrl}/${this.apiVersion}/${t}`:`${this.baseUrl}/${t}`}prepareHeaders(){const e={...this.headers};return this.useAuth&&this.authToken&&(e.Authorization=`Bearer ${this.authToken}`),e}request(e,t,r={}){return(r=>this.requestInterceptors.reduce(((r,s)=>r.then((r=>Promise.resolve(s(e,t,r))))),Promise.resolve(r)))({...r}).then((r=>this.executeRequest(e,t,r))).then((r=>this.responseInterceptors.reduce(((r,s)=>r.then((r=>Promise.resolve(s(r,e,t))))),Promise.resolve(r)))).catch((e=>this.handleError(e).then((()=>{throw e}))))}executeRequest(e,t,r={}){const{data:s=null,params:a={},headers:n={},skipAuth:i=!1,timeout:o=this.timeout,requestId:h=Date.now().toString()}=r;let l=this.buildUrl(t);if(Object.keys(a).length>0){const e=new URLSearchParams;for(const[t,r]of Object.entries(a))e.append(t,r);l+=`?${e.toString()}`}const c={...this.prepareHeaders(),...n};i&&delete c.Authorization;const d={method:e,headers:c,mode:"cors",cache:"no-cache",credentials:"same-origin",redirect:"follow",referrerPolicy:"no-referrer"};["POST","PUT","PATCH"].includes(e.toUpperCase())&&null!==s&&(d.body=JSON.stringify(s));const u=new AbortController;d.signal=u.signal,this.abortControllers.set(h,u);const p=setTimeout((()=>{this.abortControllers.has(h)&&(u.abort(),this.abortControllers.delete(h))}),o);return fetch(l,d).then((e=>(clearTimeout(p),this.abortControllers.delete(h),this.handleResponse(e)))).catch((e=>{if(clearTimeout(p),this.abortControllers.delete(h),"AbortError"===e.name)throw new APIError("Request timeout","TIMEOUT",408);throw new APIError(e.message||"Network error","NETWORK_ERROR",0,e)}))}handleResponse(e){return(()=>{const t=e.headers.get("content-type");return t&&t.includes("application/json")?e.json():e.text()})().catch((t=>{throw new APIError("Failed to parse response","PARSE_ERROR",e.status,t)})).then((t=>{if(!e.ok){const r=t.error?.code||"API_ERROR",s=t.error?.message||"Unknown API error";throw new APIError(s,r,e.status,null,t)}return t}))}handleError(e){return this.errorHandling.logErrors&&console.error("API Error:",e),this.errorHandling.onError?Promise.resolve(this.errorHandling.onError(e)):Promise.resolve()}cancelRequest(e){if(this.abortControllers.has(e)){return this.abortControllers.get(e).abort(),this.abortControllers.delete(e),!0}return!1}cancelAllRequests(){for(const e of this.abortControllers.values())e.abort();this.abortControllers.clear()}}class APIError extends Error{constructor(e,t,r,s=null,a=null){super(e),this.name="APIError",this.code=t,this.status=r,this.originalError=s,this.responseData=a,this.timestamp=new Date,Error.captureStackTrace&&Error.captureStackTrace(this,APIError)}}
//# sourceMappingURL=APIConnector.js.map