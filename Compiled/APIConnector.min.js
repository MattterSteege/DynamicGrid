class APIConnector{constructor(t={}){this.baseUrl=t.baseUrl||"",this.headers={"Content-Type":"application/json",Accept:"application/json",...t.headers},this.timeout=t.timeout||3e4,this.useAuth=t.useAuth||!1,this.authToken=t.authToken||null,this.apiVersion=t.apiVersion,this.abortControllers=new Map,this.endpoints=this.initializeEndpoints(t.endpoints||{}),this.dataTransform=this.initializeDataTransform(t.dataTransform||{}),this.errorHandling=this.initializeErrorHandling(t.errorHandling||{}),this.caching=this.initializeCaching(t.caching||{}),this.validation=this.initializeValidation(t.validation||{}),this.requestInterceptors=[],this.responseInterceptors=[],this.retryConfig={enabled:t.retry?.enabled||!1,maxAttempts:t.retry?.maxAttempts||3,delay:t.retry?.delay||1e3,backoff:t.retry?.backoff||"exponential",retryCondition:t.retry?.retryCondition||this.defaultRetryCondition.bind(this)}}initializeEndpoints(t){return{fetch:{method:"GET",endpoint:"/data"},create:{method:"POST",endpoint:"/data"},update:{method:"PUT",endpoint:"/data/{id}"},patch:{method:"PATCH",endpoint:"/data/{id}"},delete:{method:"DELETE",endpoint:"/data/{id}"},search:{method:"GET",endpoint:"/search"},bulk:{method:"POST",endpoint:"/data/bulk"},...t}}initializeDataTransform(t){return{request:t.request||(t=>t),response:t.response||(t=>t),error:t.error||(t=>t),beforeSend:t.beforeSend||(t=>t),afterReceive:t.afterReceive||(t=>t)}}initializeErrorHandling(t){return{showUserFriendlyMessages:!1!==t.showUserFriendlyMessages,logErrors:!1!==t.logErrors,customErrorMessages:t.customErrorMessages||{},onError:t.onError||null,retryableErrors:t.retryableErrors||[408,429,500,502,503,504]}}initializeCaching(t){return{enabled:t.enabled||!1,ttl:t.ttl||3e5,strategy:t.strategy||"memory",keyGenerator:t.keyGenerator||this.generateCacheKey.bind(this),cache:new Map}}initializeValidation(t){return{enabled:t.enabled||!1,schemas:t.schemas||{},validator:t.validator||this.defaultValidator.bind(this)}}addRequestInterceptor(t){this.requestInterceptors.push(t)}addResponseInterceptor(t){this.responseInterceptors.push(t)}async executeOperation(t,e=null,r={}){const a=this.endpoints[t];if(!a)throw new APIError(`Unknown operation: ${t}`,"UNKNOWN_OPERATION",400);this.validation.enabled&&e&&await this.validateData(t,e);const s=this.dataTransform.beforeSend(this.dataTransform.request(e));if("GET"===a.method&&this.caching.enabled){const e=this.caching.keyGenerator(t,s,r),a=this.getFromCache(e);if(a)return this.dataTransform.afterReceive(this.dataTransform.response(a))}let i=a.endpoint;r.pathParams&&(i=this.substitutePathParams(i,r.pathParams));const n={data:s,params:r.params||{},headers:r.headers||{},...r};let o;o=this.retryConfig.enabled?await this.executeWithRetry(a.method,i,n):await this.request(a.method,i,n);const h=this.dataTransform.afterReceive(this.dataTransform.response(o));if("GET"===a.method&&this.caching.enabled){const e=this.caching.keyGenerator(t,s,r);this.setCache(e,h)}return h}async fetchData(t={},e={}){return this.executeOperation("fetch",null,{params:t,...e})}async createData(t,e={}){return this.executeOperation("create",t,e)}async patchData(t,e={}){return this.executeOperation("patch",t,e)}async deleteData(t={}){return this.executeOperation("delete",null,t)}async searchData(t,e={}){return this.executeOperation("search",t,e)}async bulkOperation(t,e={}){return this.executeOperation("bulk",t,e)}async executeWithRetry(t,e,r){let a;for(let s=1;s<=this.retryConfig.maxAttempts;s++)try{return await this.request(t,e,r)}catch(t){if(a=t,s===this.retryConfig.maxAttempts||!this.retryConfig.retryCondition(t,s))break;let e=this.retryConfig.delay;"exponential"===this.retryConfig.backoff&&(e*=Math.pow(2,s-1)),await this.sleep(e)}throw a}defaultRetryCondition(t,e){return this.errorHandling.retryableErrors.includes(t.status)}sleep(t){return new Promise((e=>setTimeout(e,t)))}substitutePathParams(t,e){return t.replace(/\{(\w+)\}/g,((t,r)=>void 0!==e[r]?e[r]:t))}async validateData(t,e){const r=this.validation.schemas[t];if(r){if(!await this.validation.validator(e,r))throw new APIError(`Validation failed for ${t}`,"VALIDATION_ERROR",400)}}defaultValidator(t,e){return"function"!=typeof e||e(t)}generateCacheKey(t,e,r){const a={operation:t,data:e||null,params:r.params||{},pathParams:r.pathParams||{}};return JSON.stringify(a)}getFromCache(t){if(!this.caching.enabled)return null;const e=this.caching.cache.get(t);return e&&Date.now()-e.timestamp<this.caching.ttl?e.data:(e&&this.caching.cache.delete(t),null)}setCache(t,e){this.caching.enabled&&this.caching.cache.set(t,{data:e,timestamp:Date.now()})}clearCache(t){if(t){const e=new RegExp(t);for(const t of this.caching.cache.keys())e.test(t)&&this.caching.cache.delete(t)}else this.caching.cache.clear()}setAuthToken(t){this.authToken=t,this.useAuth=!!t}clearAuthToken(){this.authToken=null,this.useAuth=!1}buildUrl(t){const e=t.startsWith("/")?t.substring(1):t;return this.apiVersion?`${this.baseUrl}/${this.apiVersion}/${e}`:`${this.baseUrl}/${e}`}prepareHeaders(){const t={...this.headers};return this.useAuth&&this.authToken&&(t.Authorization=`Bearer ${this.authToken}`),t}async request(t,e,r={}){let a={...r};for(const r of this.requestInterceptors)a=await r(t,e,a);try{let r=await this.executeRequest(t,e,a);for(const a of this.responseInterceptors)r=await a(r,t,e);return r}catch(t){throw await this.handleError(t),t}}async executeRequest(t,e,r={}){const{data:a=null,params:s={},headers:i={},skipAuth:n=!1,timeout:o=this.timeout,requestId:h=Date.now().toString()}=r;let c=this.buildUrl(e);if(Object.keys(s).length>0){const t=new URLSearchParams;for(const[e,r]of Object.entries(s))t.append(e,r);c+=`?${t.toString()}`}const l={...this.prepareHeaders(),...i};n&&delete l.Authorization;const d={method:t,headers:l,mode:"cors",cache:"no-cache",credentials:"same-origin",redirect:"follow",referrerPolicy:"no-referrer"};["POST","PUT","PATCH"].includes(t.toUpperCase())&&null!==a&&(d.body=JSON.stringify(a));const u=new AbortController;d.signal=u.signal,this.abortControllers.set(h,u);const p=setTimeout((()=>{this.abortControllers.has(h)&&(u.abort(),this.abortControllers.delete(h))}),o);try{const t=await fetch(c,d);return clearTimeout(p),this.abortControllers.delete(h),await this.handleResponse(t)}catch(t){if(clearTimeout(p),this.abortControllers.delete(h),"AbortError"===t.name)throw new APIError("Request timeout","TIMEOUT",408);throw new APIError(t.message||"Network error","NETWORK_ERROR",0,t)}}async handleResponse(t){let e;try{const r=t.headers.get("content-type");e=r&&r.includes("application/json")?await t.json():await t.text()}catch(e){throw new APIError("Failed to parse response","PARSE_ERROR",t.status,e)}if(!t.ok){const r=e.error?.code||"API_ERROR",a=e.error?.message||"Unknown API error";throw new APIError(a,r,t.status,null,e)}return e}async handleError(t){this.errorHandling.logErrors&&console.error("API Error:",t),this.errorHandling.onError&&await this.errorHandling.onError(t)}cancelRequest(t){if(this.abortControllers.has(t)){return this.abortControllers.get(t).abort(),this.abortControllers.delete(t),!0}return!1}cancelAllRequests(){for(const t of this.abortControllers.values())t.abort();this.abortControllers.clear()}}class APIError extends Error{constructor(t,e,r,a=null,s=null){super(t),this.name="APIError",this.code=e,this.status=r,this.originalError=a,this.responseData=s,this.timestamp=new Date,Error.captureStackTrace&&Error.captureStackTrace(this,APIError)}}
//# sourceMappingURL=APIConnector.js.map